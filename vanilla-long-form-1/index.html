<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Unix Operating System: A Complete Guide</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: Georgia, 'Times New Roman', serif;
            line-height: 1.8;
            color: #333;
            background-color: #fafafa;
        }

        header {
            background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
            color: white;
            padding: 80px 20px;
            text-align: center;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }

        header h1 {
            font-size: 3em;
            margin-bottom: 20px;
            font-weight: 700;
            letter-spacing: -1px;
        }

        header .subtitle {
            font-size: 1.3em;
            opacity: 0.9;
            font-style: italic;
        }

        .meta {
            margin-top: 30px;
            font-size: 0.95em;
            opacity: 0.8;
        }

        article {
            max-width: 800px;
            margin: 60px auto;
            padding: 0 40px;
            background: white;
            box-shadow: 0 0 40px rgba(0,0,0,0.05);
        }

        .content {
            padding: 60px 0;
        }

        h2 {
            font-size: 2.2em;
            margin: 60px 0 30px 0;
            color: #2c3e50;
            border-bottom: 3px solid #3498db;
            padding-bottom: 15px;
        }

        h3 {
            font-size: 1.6em;
            margin: 40px 0 20px 0;
            color: #34495e;
        }

        p {
            margin-bottom: 25px;
            font-size: 1.1em;
            text-align: justify;
        }

        .lead {
            font-size: 1.4em;
            line-height: 1.7;
            color: #555;
            font-weight: 400;
            margin-bottom: 40px;
            border-left: 4px solid #3498db;
            padding-left: 30px;
            font-style: italic;
        }

        code {
            background: #f4f4f4;
            padding: 3px 8px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 0.95em;
            color: #e74c3c;
        }

        .code-block {
            background: #2c3e50;
            color: #ecf0f1;
            padding: 25px;
            border-radius: 8px;
            margin: 30px 0;
            font-family: 'Courier New', monospace;
            overflow-x: auto;
            line-height: 1.6;
        }

        .code-block code {
            background: none;
            color: #ecf0f1;
            padding: 0;
        }

        blockquote {
            border-left: 5px solid #3498db;
            padding: 20px 30px;
            margin: 40px 0;
            background: #ecf0f1;
            font-style: italic;
            font-size: 1.15em;
            color: #555;
        }

        blockquote cite {
            display: block;
            margin-top: 15px;
            font-size: 0.9em;
            color: #7f8c8d;
            font-style: normal;
        }

        ul, ol {
            margin: 25px 0 25px 40px;
        }

        li {
            margin-bottom: 15px;
            font-size: 1.1em;
        }

        .highlight-box {
            background: #fff9e6;
            border: 2px solid #f39c12;
            border-radius: 8px;
            padding: 25px;
            margin: 35px 0;
        }

        .highlight-box h3 {
            color: #f39c12;
            margin-top: 0;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin: 30px 0;
            font-size: 1em;
        }

        th, td {
            padding: 15px;
            text-align: left;
            border-bottom: 1px solid #ddd;
        }

        th {
            background: #34495e;
            color: white;
            font-weight: 600;
        }

        tr:hover {
            background: #f5f5f5;
        }

        .toc {
            background: #ecf0f1;
            padding: 30px;
            border-radius: 8px;
            margin: 40px 0;
        }

        .toc h3 {
            margin-top: 0;
            color: #2c3e50;
        }

        .toc ul {
            list-style: none;
            margin: 20px 0 0 0;
        }

        .toc li {
            margin-bottom: 10px;
        }

        .toc a {
            color: #3498db;
            text-decoration: none;
            font-size: 1.05em;
        }

        .toc a:hover {
            text-decoration: underline;
        }

        footer {
            background: #2c3e50;
            color: white;
            padding: 40px 20px;
            text-align: center;
            margin-top: 60px;
        }

        .author-bio {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 30px;
            margin: 50px 0;
            border-top: 4px solid #3498db;
        }

        .author-bio h3 {
            margin-top: 0;
        }

        @media (max-width: 768px) {
            header h1 {
                font-size: 2em;
            }

            article {
                padding: 0 20px;
            }

            .content {
                padding: 30px 0;
            }

            h2 {
                font-size: 1.8em;
            }

            .lead {
                font-size: 1.2em;
            }
        }
    </style>
</head>
<body>
    <header>
        <h1>The Unix Operating System</h1>
        <p class="subtitle">A Journey Through Computing History and Philosophy</p>
        <div class="meta">Published: January 21, 2026 | Reading time: 25 minutes</div>
    </header>

    <article>
        <div class="content">
            <p class="lead">
                Unix stands as one of the most influential operating systems ever created, shaping the foundation of modern computing and software development. From its humble beginnings in Bell Labs to its widespread adoption across servers, workstations, and embedded systems, Unix has left an indelible mark on technology.
            </p>

            <div class="toc">
                <h3>Table of Contents</h3>
                <ul>
                    <li><a href="#history">The History of Unix</a></li>
                    <li><a href="#philosophy">Unix Philosophy</a></li>
                    <li><a href="#architecture">System Architecture</a></li>
                    <li><a href="#filesystem">The File System</a></li>
                    <li><a href="#commands">Essential Commands</a></li>
                    <li><a href="#shell">The Unix Shell</a></li>
                    <li><a href="#variants">Unix Variants and Descendants</a></li>
                    <li><a href="#legacy">Legacy and Impact</a></li>
                </ul>
            </div>

            <h2 id="history">The History of Unix</h2>

            <p>
                The story of Unix begins in 1969 at Bell Labs, a research facility of AT&T. After the withdrawal from the ambitious Multics project, Ken Thompson, Dennis Ritchie, and their colleagues found themselves with some idle time and access to a PDP-7 minicomputer. What started as Thompson's effort to port a space travel game evolved into something far more significant.
            </p>

            <p>
                Thompson initially created a simple file system, process control, and command interpreter. The system was so minimal that Brian Kernighan jokingly called it "Unics" (Uniplexed Information and Computing Service), a play on "Multics" (Multiplexed Information and Computer Services). The name eventually morphed into Unix.
            </p>

            <blockquote>
                "Unix is simple. It just takes a genius to understand its simplicity."
                <cite>— Dennis Ritchie</cite>
            </blockquote>

            <h3>The Birth of C</h3>

            <p>
                One of the most revolutionary aspects of Unix was its reimplementation in the C programming language in 1972. Prior to this, operating systems were typically written in assembly language, making them highly platform-specific and difficult to port. Dennis Ritchie developed C specifically for systems programming, and the decision to rewrite Unix in C made it one of the first portable operating systems.
            </p>

            <p>
                This portability was groundbreaking. For the first time, an operating system could be moved to different hardware platforms with relative ease. This decision would prove to be one of the most important factors in Unix's eventual widespread adoption and influence.
            </p>

            <h3>The AT&T Divestiture and BSD</h3>

            <p>
                AT&T, as a regulated monopoly, was initially restricted from selling computer products. This led to Unix being licensed to universities for a nominal fee, including the University of California, Berkeley. Graduate students and faculty at Berkeley began extending and improving Unix, leading to the Berkeley Software Distribution (BSD) versions.
            </p>

            <p>
                BSD introduced many innovations that would become standard features, including the vi text editor, the C shell, TCP/IP networking, and virtual memory. The BSD variants would go on to spawn their own lineage, including FreeBSD, OpenBSD, and NetBSD, which remain influential today.
            </p>

            <h2 id="philosophy">Unix Philosophy</h2>

            <p>
                Beyond its technical achievements, Unix introduced a philosophy of software design that has influenced generations of programmers. This philosophy emphasizes simplicity, modularity, and composability. The Unix way of thinking has shaped not just operating systems, but software development practices across the industry.
            </p>

            <h3>Core Principles</h3>

            <p>
                Doug McIlroy, who invented Unix pipes, summarized the Unix philosophy succinctly:
            </p>

            <blockquote>
                "Write programs that do one thing and do it well. Write programs to work together. Write programs to handle text streams, because that is a universal interface."
            </blockquote>

            <p>
                This philosophy manifests in several key principles:
            </p>

            <ul>
                <li><strong>Modularity:</strong> Build small, focused programs that perform specific tasks well</li>
                <li><strong>Composability:</strong> Design programs to work together through standard interfaces</li>
                <li><strong>Text as universal interface:</strong> Use plain text for data storage and inter-program communication</li>
                <li><strong>Everything is a file:</strong> Provide a uniform interface for devices, processes, and data</li>
                <li><strong>Simplicity:</strong> Favor simple, elegant solutions over complex ones</li>
                <li><strong>Rapid prototyping:</strong> Build working systems quickly and iterate</li>
            </ul>

            <div class="highlight-box">
                <h3>The Rule of Least Surprise</h3>
                <p>
                    Programs should behave in ways that are predictable and intuitive. Users should not be surprised by unexpected behavior. This principle encourages consistency in design and helps create systems that are easier to learn and use.
                </p>
            </div>

            <h2 id="architecture">System Architecture</h2>

            <p>
                Unix's architecture is elegantly simple, consisting of three main layers: the kernel, the shell, and the utilities. This layered approach provides both flexibility and security, allowing users to interact with the system through various interfaces while maintaining a stable core.
            </p>

            <h3>The Kernel</h3>

            <p>
                At the heart of Unix is the kernel, which manages the system's resources and provides essential services. The kernel handles process scheduling, memory management, device I/O, and system calls. It operates with the highest level of privilege and mediates all access to hardware resources.
            </p>

            <p>
                The Unix kernel design philosophy emphasizes a minimal, monolithic core that provides only essential services. Device drivers and file systems are typically compiled into the kernel, though modern Unix-like systems often support loadable kernel modules for flexibility.
            </p>

            <h3>The Shell</h3>

            <p>
                The shell serves as the primary interface between users and the kernel. It interprets commands, manages processes, and provides a powerful programming environment. The original Unix shell, written by Ken Thompson, was simple but effective. Later shells like the Bourne shell, C shell, and Korn shell added features like scripting capabilities, job control, and command history.
            </p>

            <p>
                The shell's power lies in its ability to combine simple programs into complex operations through pipes and redirection. This composability is a fundamental aspect of the Unix philosophy.
            </p>

            <h3>System Calls</h3>

            <p>
                Programs interact with the kernel through system calls, which provide a stable interface for requesting kernel services. Key system calls include:
            </p>

            <table>
                <thead>
                    <tr>
                        <th>System Call</th>
                        <th>Purpose</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>fork()</td>
                        <td>Create a new process</td>
                    </tr>
                    <tr>
                        <td>exec()</td>
                        <td>Execute a program</td>
                    </tr>
                    <tr>
                        <td>open()</td>
                        <td>Open a file</td>
                    </tr>
                    <tr>
                        <td>read()</td>
                        <td>Read from a file descriptor</td>
                    </tr>
                    <tr>
                        <td>write()</td>
                        <td>Write to a file descriptor</td>
                    </tr>
                    <tr>
                        <td>close()</td>
                        <td>Close a file descriptor</td>
                    </tr>
                    <tr>
                        <td>pipe()</td>
                        <td>Create an inter-process communication channel</td>
                    </tr>
                    <tr>
                        <td>kill()</td>
                        <td>Send a signal to a process</td>
                    </tr>
                </tbody>
            </table>

            <h2 id="filesystem">The File System</h2>

            <p>
                The Unix file system is one of its most elegant and influential features. It provides a hierarchical structure that begins at the root directory (/) and branches out into subdirectories. This simple tree structure has proven remarkably flexible and has been adopted by virtually every modern operating system.
            </p>

            <h3>Everything is a File</h3>

            <p>
                A cornerstone concept in Unix is that "everything is a file." This abstraction means that devices, network connections, processes, and even inter-process communication channels are all accessed through the same file interface. This uniformity simplifies programming and system administration.
            </p>

            <p>
                For example, to write to a terminal, you write to a file. To read from a network socket, you read from a file descriptor. This consistency reduces the conceptual burden on programmers and creates a more cohesive system.
            </p>

            <h3>File System Hierarchy</h3>

            <p>
                The Unix file system follows a standard hierarchy, though variations exist across different Unix variants. Common directories include:
            </p>

            <ul>
                <li><code>/bin</code> - Essential command binaries</li>
                <li><code>/etc</code> - System configuration files</li>
                <li><code>/home</code> - User home directories</li>
                <li><code>/usr</code> - User programs and data</li>
                <li><code>/var</code> - Variable data like logs</li>
                <li><code>/dev</code> - Device files</li>
                <li><code>/tmp</code> - Temporary files</li>
                <li><code>/lib</code> - Shared libraries</li>
            </ul>

            <h3>Inodes and File Metadata</h3>

            <p>
                Unix file systems use inodes (index nodes) to store metadata about files. An inode contains information such as file size, ownership, permissions, and pointers to the actual data blocks on disk. The file name is stored separately in directory entries, which associate names with inode numbers.
            </p>

            <p>
                This separation allows Unix to implement hard links, where multiple directory entries can point to the same inode, effectively giving one file multiple names. This is distinct from symbolic links, which are special files containing paths to other files.
            </p>

            <h2 id="commands">Essential Commands</h2>

            <p>
                Unix's power comes not from large, monolithic applications, but from a collection of small, focused utilities that can be combined in countless ways. Mastering these tools is key to becoming proficient with Unix systems.
            </p>

            <h3>File Operations</h3>

            <p>
                Basic file operations form the foundation of Unix command-line work:
            </p>

            <div class="code-block">
<code># List files
ls -la

# Copy files
cp source.txt destination.txt

# Move or rename files
mv oldname.txt newname.txt

# Remove files
rm file.txt

# Create directories
mkdir new_directory

# Remove directories
rmdir empty_directory
rm -rf non_empty_directory</code>
            </div>

            <h3>Text Processing</h3>

            <p>
                Unix excels at text processing, with a rich set of tools for manipulating text streams:
            </p>

            <div class="code-block">
<code># Display file contents
cat file.txt

# View file with paging
less file.txt

# Search for patterns
grep "pattern" file.txt

# Stream editor for text transformation
sed 's/old/new/g' file.txt

# Pattern scanning and processing
awk '{print $1}' file.txt

# Sort lines
sort file.txt

# Count lines, words, characters
wc file.txt

# Extract columns
cut -d',' -f1,3 data.csv</code>
            </div>

            <h3>Process Management</h3>

            <p>
                Managing processes is a fundamental task in Unix:
            </p>

            <div class="code-block">
<code># List running processes
ps aux

# Display dynamic process information
top

# Send signals to processes
kill -9 PID

# Run command in background
command &

# List background jobs
jobs

# Bring job to foreground
fg %1</code>
            </div>

            <h3>Pipes and Redirection</h3>

            <p>
                The true power of Unix commands emerges when they're combined using pipes and redirection:
            </p>

            <div class="code-block">
<code># Pipe output to another command
ls -l | grep ".txt"

# Redirect output to file
echo "Hello" > file.txt

# Append to file
echo "World" >> file.txt

# Redirect input from file
sort < unsorted.txt

# Redirect both stdout and stderr
command > output.txt 2>&1

# Chain multiple commands
cat file.txt | grep "error" | sort | uniq -c</code>
            </div>

            <div class="highlight-box">
                <h3>The Power of Composition</h3>
                <p>
                    One of Unix's greatest strengths is the ability to combine simple commands into powerful operations. For example, to find the ten most frequently occurring words in a text file:
                </p>
                <div class="code-block">
<code>cat file.txt | tr ' ' '\n' | sort | uniq -c | sort -rn | head -10</code>
                </div>
                <p>
                    This pipeline transforms spaces to newlines, sorts the words, counts unique occurrences, sorts by frequency, and displays the top 10. Each tool does one thing well, but together they perform a sophisticated analysis.
                </p>
            </div>

            <h2 id="shell">The Unix Shell</h2>

            <p>
                The shell is more than just a command interpreter; it's a powerful programming environment. Shell scripts automate tasks, system administration, and complex workflows. The shell's scripting capabilities make Unix systems highly automatable and customizable.
            </p>

            <h3>Shell Scripting</h3>

            <p>
                Shell scripts are text files containing sequences of commands. They support variables, conditionals, loops, and functions, making them suitable for everything from simple automation to complex system administration tasks.
            </p>

            <div class="code-block">
<code>#!/bin/bash

# A simple backup script
SOURCE_DIR="/home/user/documents"
BACKUP_DIR="/backup"
DATE=$(date +%Y%m%d)

# Create backup directory if it doesn't exist
mkdir -p "$BACKUP_DIR"

# Create compressed archive
tar -czf "$BACKUP_DIR/backup-$DATE.tar.gz" "$SOURCE_DIR"

# Check if backup was successful
if [ $? -eq 0 ]; then
    echo "Backup completed successfully"
else
    echo "Backup failed"
    exit 1
fi

# Remove backups older than 7 days
find "$BACKUP_DIR" -name "backup-*.tar.gz" -mtime +7 -delete</code>
            </div>

            <h3>Environment and Variables</h3>

            <p>
                The shell maintains an environment of variables that affect command execution and provide information about the system:
            </p>

            <div class="code-block">
<code># Set a variable
NAME="John"

# Use a variable
echo "Hello, $NAME"

# Export variable to child processes
export PATH="/usr/local/bin:$PATH"

# View all environment variables
env

# Common environment variables
echo $HOME    # User's home directory
echo $PATH    # Command search path
echo $USER    # Current username
echo $SHELL   # Current shell</code>
            </div>

            <h3>Job Control</h3>

            <p>
                Modern Unix shells support job control, allowing users to manage multiple processes:
            </p>

            <ul>
                <li>Run commands in the background with <code>&</code></li>
                <li>Suspend running processes with Ctrl-Z</li>
                <li>Resume processes in background with <code>bg</code></li>
                <li>Bring processes to foreground with <code>fg</code></li>
                <li>List jobs with <code>jobs</code></li>
            </ul>

            <h2 id="variants">Unix Variants and Descendants</h2>

            <p>
                Unix's influence extends far beyond the original system. Over the decades, numerous variants and descendants have emerged, each contributing innovations while maintaining the core Unix philosophy.
            </p>

            <h3>Commercial Unix Systems</h3>

            <p>
                Several commercial Unix variants have played significant roles in computing history:
            </p>

            <ul>
                <li><strong>Solaris</strong> - Sun Microsystems' Unix, known for scalability and advanced features like ZFS and DTrace</li>
                <li><strong>AIX</strong> - IBM's Unix for their Power Systems, emphasizing enterprise features and reliability</li>
                <li><strong>HP-UX</strong> - Hewlett-Packard's Unix, focusing on mission-critical applications</li>
                <li><strong>IRIX</strong> - Silicon Graphics' Unix, optimized for graphics and scientific computing</li>
            </ul>

            <h3>BSD Descendants</h3>

            <p>
                The Berkeley Software Distribution spawned a family of free and open-source operating systems:
            </p>

            <ul>
                <li><strong>FreeBSD</strong> - Emphasizes performance and advanced networking features, widely used in servers and embedded systems</li>
                <li><strong>OpenBSD</strong> - Prioritizes security and code correctness, known for proactive security practices</li>
                <li><strong>NetBSD</strong> - Focuses on portability, running on an extremely wide range of hardware platforms</li>
                <li><strong>DragonFly BSD</strong> - Explores novel approaches to multiprocessing and system design</li>
            </ul>

            <h3>macOS and Darwin</h3>

            <p>
                Apple's macOS is built on Darwin, a Unix-like operating system combining components from FreeBSD, Mach kernel, and Apple's own innovations. This makes macOS a certified Unix system (certified to the Single UNIX Specification), bringing Unix to millions of desktop users.
            </p>

            <h3>Linux and Unix-like Systems</h3>

            <p>
                While not Unix in the strict sense, Linux has become the most widely used Unix-like operating system. Created by Linus Torvalds in 1991, Linux was designed to be compatible with Unix principles and APIs while being completely independent of the original Unix codebase.
            </p>

            <p>
                Linux distributions have achieved remarkable success in servers, embedded systems, mobile devices (Android), and increasingly on desktop computers. The combination of the Linux kernel with GNU utilities and other open-source software has created powerful, flexible systems that embody Unix philosophy while pushing innovation in new directions.
            </p>

            <h2 id="legacy">Legacy and Impact</h2>

            <p>
                Unix's influence on computing cannot be overstated. Its design principles, tools, and philosophy have shaped multiple generations of operating systems and software development practices.
            </p>

            <h3>Technical Contributions</h3>

            <p>
                Unix introduced or popularized numerous technical innovations:
            </p>

            <ul>
                <li>Hierarchical file systems with a unified namespace</li>
                <li>Process abstraction and inter-process communication</li>
                <li>Pipes for composing programs</li>
                <li>Shell scripting for automation</li>
                <li>Regular expressions for pattern matching</li>
                <li>Portable system interfaces (POSIX)</li>
                <li>Network protocols (TCP/IP in BSD)</li>
            </ul>

            <h3>Cultural Impact</h3>

            <p>
                Beyond technical achievements, Unix fostered a culture of openness, collaboration, and elegant design. The practice of sharing source code and ideas, common in early Unix development, prefigured the open-source movement. The Unix philosophy of simplicity and composability influenced software design far beyond operating systems.
            </p>

            <p>
                The mailing lists, Usenet groups, and informal networks that grew around Unix development helped establish patterns of collaboration that continue in modern open-source communities. The Unix hacker culture valued cleverness, efficiency, and elegant solutions to complex problems.
            </p>

            <h3>Educational Influence</h3>

            <p>
                Unix has been instrumental in computer science education. Its relatively simple design made it ideal for teaching operating system concepts. Books like "The Unix Programming Environment" by Kernighan and Pike and "Advanced Programming in the UNIX Environment" by Stevens became standard references, educating generations of programmers.
            </p>

            <p>
                The availability of Unix source code (particularly in academic settings) allowed students to study a real, working operating system. This hands-on learning approach influenced how operating systems are taught and understood.
            </p>

            <h3>Modern Relevance</h3>

            <p>
                Today, Unix's descendants and influenced systems dominate computing. Linux powers the majority of web servers, supercomputers, and cloud infrastructure. macOS brings Unix to millions of desktop users. Android, based on Linux, is the most widely used mobile operating system. FreeBSD influences network infrastructure and forms the basis for console operating systems.
            </p>

            <p>
                The Unix philosophy remains relevant in modern software development. Microservices architecture echoes the Unix principle of small, focused programs. Container technologies like Docker embody Unix ideas about isolation and composability. DevOps practices embrace Unix's emphasis on automation through scripting and command-line tools.
            </p>

            <blockquote>
                "Unix is not so much an operating system as it is a way of thinking about software."
                <cite>— Brian Kernighan</cite>
            </blockquote>

            <h3>Challenges and Evolution</h3>

            <p>
                While Unix's core concepts have proven remarkably durable, the computing landscape has changed dramatically since 1969. Modern systems must address challenges that didn't exist in Unix's early days: distributed computing, containerization, real-time requirements, and security threats.
            </p>

            <p>
                Contemporary Unix-like systems have evolved to meet these challenges while attempting to maintain backward compatibility and philosophical consistency. This tension between preservation and innovation continues to shape operating system development.
            </p>

            <h2>Conclusion</h2>

            <p>
                Unix represents more than just an operating system; it embodies a philosophy of software design that has profoundly influenced computing. Its emphasis on simplicity, modularity, and composability created a foundation that has proven remarkably adaptable across decades of technological change.
            </p>

            <p>
                From its origins in a Bell Labs research project to its current ubiquity in servers, mobile devices, and embedded systems, Unix has demonstrated the power of elegant design and clear thinking. The tools, concepts, and principles pioneered by Unix continue to shape how we build and interact with software.
            </p>

            <p>
                As computing continues to evolve, Unix's legacy persists not just in the systems that bear its name or heritage, but in the way developers approach problems, design systems, and think about software. In an industry characterized by rapid change, Unix's enduring influence stands as a testament to the power of good ideas, simple designs, and the Unix philosophy itself.
            </p>

            <div class="author-bio">
                <h3>About This Article</h3>
                <p>
                    This comprehensive guide explores the history, philosophy, and technical foundations of Unix, one of computing's most influential operating systems. Whether you're a student learning about operating systems, a developer seeking to understand Unix principles, or a technology enthusiast interested in computing history, this article provides a thorough introduction to Unix and its lasting impact on modern computing.
                </p>
            </div>
        </div>
    </article>

    <footer>
        <p>&copy; 2026 Unix Guide. All rights reserved.</p>
        <p>A deep dive into the operating system that changed computing forever.</p>
    </footer>
</body>
</html>
